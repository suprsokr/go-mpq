// Copyright (c) 2025 suprsokr
// SPDX-License-Identifier: MIT

// PKWare Data Compression Library (DCL) - Explode algorithm
// Ported from StormLib's pklib implementation by Ladislav Zezula
// Original PKWARE DCL copyright 1989-1995 PKWARE Inc.

package mpq

import (
	"errors"
	"fmt"
)

// PKWare compression types
const (
	pkCmpBinary = 0 // Binary compression
	pkCmpASCII  = 1 // ASCII compression
)

// Lookup tables for PKWare decompression
var (
	// Distance bits table
	pkDistBits = [0x40]byte{
		0x02, 0x04, 0x04, 0x05, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
		0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
		0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
		0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	}

	// Distance code table
	pkDistCode = [0x40]byte{
		0x03, 0x0D, 0x05, 0x19, 0x09, 0x11, 0x01, 0x3E, 0x1E, 0x2E, 0x0E, 0x36, 0x16, 0x26, 0x06, 0x3A,
		0x1A, 0x2A, 0x0A, 0x32, 0x12, 0x22, 0x42, 0x02, 0x7C, 0x3C, 0x5C, 0x1C, 0x6C, 0x2C, 0x4C, 0x0C,
		0x74, 0x34, 0x54, 0x14, 0x64, 0x24, 0x44, 0x04, 0x78, 0x38, 0x58, 0x18, 0x68, 0x28, 0x48, 0x08,
		0xF0, 0x70, 0xB0, 0x30, 0xD0, 0x50, 0x90, 0x10, 0xE0, 0x60, 0xA0, 0x20, 0xC0, 0x40, 0x80, 0x00,
	}

	// Extra length bits table
	pkExLenBits = [0x10]byte{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
	}

	// Length base table
	pkLenBase = [0x10]uint16{
		0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007,
		0x0008, 0x000A, 0x000E, 0x0016, 0x0026, 0x0046, 0x0086, 0x0106,
	}

	// Length bits table
	pkLenBits = [0x10]byte{
		0x03, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x07, 0x07,
	}

	// Length code table
	pkLenCode = [0x10]byte{
		0x05, 0x03, 0x01, 0x06, 0x0A, 0x02, 0x0C, 0x14, 0x04, 0x18, 0x08, 0x30, 0x10, 0x20, 0x40, 0x00,
	}

	// ASCII character bits table
	pkChBitsAsc = [0x100]byte{
		0x0B, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x08, 0x07, 0x0C, 0x0C, 0x07, 0x0C, 0x0C,
		0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0D, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
		0x04, 0x0A, 0x08, 0x0C, 0x0A, 0x0C, 0x0A, 0x08, 0x07, 0x07, 0x08, 0x09, 0x07, 0x06, 0x07, 0x08,
		0x07, 0x06, 0x07, 0x07, 0x07, 0x07, 0x08, 0x07, 0x07, 0x08, 0x08, 0x0C, 0x0B, 0x07, 0x09, 0x0B,
		0x0C, 0x06, 0x07, 0x06, 0x06, 0x05, 0x07, 0x08, 0x08, 0x06, 0x0B, 0x09, 0x06, 0x07, 0x06, 0x06,
		0x07, 0x0B, 0x06, 0x06, 0x06, 0x07, 0x09, 0x08, 0x09, 0x09, 0x0B, 0x08, 0x0B, 0x09, 0x0C, 0x08,
		0x0C, 0x05, 0x06, 0x06, 0x06, 0x05, 0x06, 0x06, 0x06, 0x05, 0x0B, 0x07, 0x05, 0x06, 0x05, 0x05,
		0x06, 0x0A, 0x05, 0x05, 0x05, 0x05, 0x08, 0x07, 0x08, 0x08, 0x0A, 0x0B, 0x0B, 0x0C, 0x0C, 0x0C,
		0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D,
		0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D,
		0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D,
		0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
		0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
		0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
		0x0D, 0x0C, 0x0D, 0x0D, 0x0D, 0x0C, 0x0D, 0x0D, 0x0D, 0x0C, 0x0D, 0x0D, 0x0D, 0x0D, 0x0C, 0x0D,
		0x0D, 0x0D, 0x0C, 0x0C, 0x0C, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D,
	}

	// ASCII character code table
	pkChCodeAsc = [0x100]uint16{
		0x0490, 0x0FE0, 0x07E0, 0x0BE0, 0x03E0, 0x0DE0, 0x05E0, 0x09E0,
		0x01E0, 0x00B8, 0x0062, 0x0EE0, 0x06E0, 0x0022, 0x0AE0, 0x02E0,
		0x0CE0, 0x04E0, 0x08E0, 0x00E0, 0x0F60, 0x0760, 0x0B60, 0x0360,
		0x0D60, 0x0560, 0x1240, 0x0960, 0x0160, 0x0E60, 0x0660, 0x0A60,
		0x000F, 0x0250, 0x0038, 0x0260, 0x0050, 0x0C60, 0x0390, 0x00D8,
		0x0042, 0x0002, 0x0058, 0x01B0, 0x007C, 0x0029, 0x003C, 0x0098,
		0x005C, 0x0009, 0x001C, 0x006C, 0x002C, 0x004C, 0x0018, 0x000C,
		0x0074, 0x00E8, 0x0068, 0x0460, 0x0090, 0x0034, 0x00B0, 0x0710,
		0x0860, 0x0031, 0x0054, 0x0011, 0x0021, 0x0017, 0x0014, 0x00A8,
		0x0028, 0x0001, 0x0310, 0x0130, 0x003E, 0x0064, 0x001E, 0x002E,
		0x0024, 0x0510, 0x000E, 0x0036, 0x0016, 0x0044, 0x0030, 0x00C8,
		0x01D0, 0x00D0, 0x0110, 0x0048, 0x0610, 0x0150, 0x0060, 0x0088,
		0x0FA0, 0x0007, 0x0026, 0x0006, 0x003A, 0x001B, 0x001A, 0x002A,
		0x000A, 0x000B, 0x0210, 0x0004, 0x0013, 0x0032, 0x0003, 0x001D,
		0x0012, 0x0190, 0x000D, 0x0015, 0x0005, 0x0019, 0x0008, 0x0078,
		0x00F0, 0x0070, 0x0290, 0x0410, 0x0010, 0x07A0, 0x0BA0, 0x03A0,
		0x0240, 0x1C40, 0x0C40, 0x1440, 0x0440, 0x1840, 0x0840, 0x1040,
		0x0040, 0x1F80, 0x0F80, 0x1780, 0x0780, 0x1B80, 0x0B80, 0x1380,
		0x0380, 0x1D80, 0x0D80, 0x1580, 0x0580, 0x1980, 0x0980, 0x1180,
		0x0180, 0x1E80, 0x0E80, 0x1680, 0x0680, 0x1A80, 0x0A80, 0x1280,
		0x0280, 0x1C80, 0x0C80, 0x1480, 0x0480, 0x1880, 0x0880, 0x1080,
		0x0080, 0x1F00, 0x0F00, 0x1700, 0x0700, 0x1B00, 0x0B00, 0x1300,
		0x0DA0, 0x05A0, 0x09A0, 0x01A0, 0x0EA0, 0x06A0, 0x0AA0, 0x02A0,
		0x0CA0, 0x04A0, 0x08A0, 0x00A0, 0x0F20, 0x0720, 0x0B20, 0x0320,
		0x0D20, 0x0520, 0x0920, 0x0120, 0x0E20, 0x0620, 0x0A20, 0x0220,
		0x0C20, 0x0420, 0x0820, 0x0020, 0x0FC0, 0x07C0, 0x0BC0, 0x03C0,
		0x0DC0, 0x05C0, 0x09C0, 0x01C0, 0x0EC0, 0x06C0, 0x0AC0, 0x02C0,
		0x0CC0, 0x04C0, 0x08C0, 0x00C0, 0x0F40, 0x0740, 0x0B40, 0x0340,
		0x0300, 0x0D40, 0x1D00, 0x0D00, 0x1500, 0x0540, 0x0500, 0x1900,
		0x0900, 0x0940, 0x1100, 0x0100, 0x1E00, 0x0E00, 0x0140, 0x1600,
		0x0600, 0x1A00, 0x0E40, 0x0640, 0x0A40, 0x0A00, 0x1200, 0x0200,
		0x1C00, 0x0C00, 0x1400, 0x0400, 0x1800, 0x0800, 0x1000, 0x0000,
	}
)

// pkDecompressor holds state for PKWare decompression
type pkDecompressor struct {
	input     []byte // Input data
	inPos     int    // Position in input
	output    []byte // Output buffer
	outPos    int    // Position in output
	bitBuf    uint32 // Bit buffer
	extraBits uint32 // Extra bits in buffer

	cmpType   uint32 // Compression type (binary/ascii)
	dsizeBits uint32 // Dictionary size bits
	dsizeMask uint32 // Dictionary size mask

	// Decode tables
	distPos [0x100]byte // Distance position table
	lenPos  [0x100]byte // Length position table

	// ASCII tables
	chBitsAsc [0x100]byte
	offs2C34  [0x100]byte
	offs2D34  [0x100]byte
	offs2E34  [0x80]byte
	offs2EB4  [0x100]byte
}

// decompressPKWare decompresses PKWare DCL compressed data
func decompressPKWare(input []byte, outputSize uint32) ([]byte, error) {
	if len(input) < 4 {
		return nil, errors.New("pkware: input too short")
	}

	d := &pkDecompressor{
		input:  input,
		inPos:  0,
		output: make([]byte, outputSize),
		outPos: 0,
	}

	// Read compression type
	d.cmpType = uint32(input[0])
	if d.cmpType != pkCmpBinary && d.cmpType != pkCmpASCII {
		return nil, fmt.Errorf("pkware: invalid compression type: %d", d.cmpType)
	}

	// Read dictionary size bits
	d.dsizeBits = uint32(input[1])
	if d.dsizeBits < 4 || d.dsizeBits > 6 {
		return nil, fmt.Errorf("pkware: invalid dictionary size: %d", d.dsizeBits)
	}
	d.dsizeMask = 0xFFFF >> (16 - d.dsizeBits)

	// Initialize bit buffer
	d.bitBuf = uint32(input[2])
	d.extraBits = 0
	d.inPos = 3

	// Generate decode tables
	d.genDecodeTabs(d.distPos[:], pkDistCode[:], pkDistBits[:], 0x40)
	d.genDecodeTabs(d.lenPos[:], pkLenCode[:], pkLenBits[:], 0x10)

	// Generate ASCII tables if needed
	if d.cmpType == pkCmpASCII {
		copy(d.chBitsAsc[:], pkChBitsAsc[:])
		d.genAscTabs()
	}

	// Decompress
	if err := d.expand(); err != nil {
		return nil, err
	}

	return d.output[:d.outPos], nil
}

// genDecodeTabs generates decode tables
func (d *pkDecompressor) genDecodeTabs(positions []byte, codes []byte, bits []byte, count int) {
	for i := 0; i < count; i++ {
		length := 1 << bits[i]
		for idx := int(codes[i]); idx < 0x100; idx += length {
			positions[idx] = byte(i)
		}
	}
}

// genAscTabs generates ASCII decode tables
func (d *pkDecompressor) genAscTabs() {
	for i := 0xFF; i >= 0; i-- {
		code := pkChCodeAsc[i]
		bits := d.chBitsAsc[i]

		if bits <= 8 {
			add := uint16(1 << bits)
			for acc := code; acc < 0x100; acc += add {
				d.offs2C34[acc] = byte(i)
			}
		} else if (code & 0xFF) != 0 {
			d.offs2C34[code&0xFF] = 0xFF

			if (code & 0x3F) != 0 {
				bits -= 4
				d.chBitsAsc[i] = bits
				add := uint16(1 << bits)
				for acc := code >> 4; acc < 0x100; acc += add {
					d.offs2D34[acc] = byte(i)
				}
			} else {
				bits -= 6
				d.chBitsAsc[i] = bits
				add := uint16(1 << bits)
				for acc := code >> 6; acc < 0x80; acc += add {
					d.offs2E34[acc] = byte(i)
				}
			}
		} else {
			bits -= 8
			d.chBitsAsc[i] = bits
			add := uint16(1 << bits)
			for acc := code >> 8; acc < 0x100; acc += add {
				d.offs2EB4[acc] = byte(i)
			}
		}
	}
}

// wasteBits removes bits from buffer, reloading if needed
func (d *pkDecompressor) wasteBits(nBits uint32) error {
	if nBits <= d.extraBits {
		d.extraBits -= nBits
		d.bitBuf >>= nBits
		return nil
	}

	d.bitBuf >>= d.extraBits
	if d.inPos >= len(d.input) {
		return errors.New("pkware: unexpected end of input")
	}

	d.bitBuf |= uint32(d.input[d.inPos]) << 8
	d.inPos++
	d.bitBuf >>= (nBits - d.extraBits)
	d.extraBits = d.extraBits - nBits + 8

	return nil
}

// decodeLiteral decodes a literal or length value
func (d *pkDecompressor) decodeLiteral() (uint32, error) {
	// Check if this is a literal or a reference
	if (d.bitBuf & 1) != 0 {
		// It's a reference - decode length
		if err := d.wasteBits(1); err != nil {
			return 0, err
		}

		lenIndex := d.lenPos[d.bitBuf&0xFF]
		if err := d.wasteBits(uint32(pkLenBits[lenIndex])); err != nil {
			return 0, err
		}

		extraBits := pkExLenBits[lenIndex]
		if extraBits != 0 {
			extra := d.bitBuf & ((1 << extraBits) - 1)
			if err := d.wasteBits(uint32(extraBits)); err != nil {
				return 0, err
			}
			return uint32(pkLenBase[lenIndex]) + extra + 0x100, nil
		}
		return uint32(pkLenBase[lenIndex]) + 0x100, nil
	}

	// It's a literal
	if err := d.wasteBits(1); err != nil {
		return 0, err
	}

	if d.cmpType == pkCmpBinary {
		// Binary mode - return raw byte
		value := d.bitBuf & 0xFF
		if err := d.wasteBits(8); err != nil {
			return 0, err
		}
		return value, nil
	}

	// ASCII mode
	if (d.bitBuf & 0xFF) != 0 {
		value := d.offs2C34[d.bitBuf&0xFF]
		if value == 0xFF {
			if (d.bitBuf & 0x3F) != 0 {
				if err := d.wasteBits(4); err != nil {
					return 0, err
				}
				value = d.offs2D34[d.bitBuf&0xFF]
			} else {
				if err := d.wasteBits(6); err != nil {
					return 0, err
				}
				value = d.offs2E34[d.bitBuf&0x7F]
			}
		}
		if err := d.wasteBits(uint32(d.chBitsAsc[value])); err != nil {
			return 0, err
		}
		return uint32(value), nil
	}

	if err := d.wasteBits(8); err != nil {
		return 0, err
	}
	value := d.offs2EB4[d.bitBuf&0xFF]
	if err := d.wasteBits(uint32(d.chBitsAsc[value])); err != nil {
		return 0, err
	}
	return uint32(value), nil
}

// decodeDistance decodes a distance value
func (d *pkDecompressor) decodeDistance(length uint32) (uint32, error) {
	distIndex := d.distPos[d.bitBuf&0xFF]
	if err := d.wasteBits(uint32(pkDistBits[distIndex])); err != nil {
		return 0, err
	}

	var distance uint32
	if length == 2 {
		distance = (uint32(distIndex) << 2) | (d.bitBuf & 0x03)
		if err := d.wasteBits(2); err != nil {
			return 0, err
		}
	} else {
		distance = (uint32(distIndex) << d.dsizeBits) | (d.bitBuf & d.dsizeMask)
		if err := d.wasteBits(d.dsizeBits); err != nil {
			return 0, err
		}
	}

	return distance + 1, nil
}

// expand performs the main decompression loop
func (d *pkDecompressor) expand() error {
	for {
		literal, err := d.decodeLiteral()
		if err != nil {
			return err
		}

		if literal < 0x100 {
			// Output a literal byte
			if d.outPos >= len(d.output) {
				return errors.New("pkware: output buffer overflow")
			}
			d.output[d.outPos] = byte(literal)
			d.outPos++
		} else if literal == 0x306 {
			// End of stream marker
			break
		} else {
			// Copy from previous output
			copyLen := literal - 0xFE // length = literal - 0x100 + 2

			distance, err := d.decodeDistance(copyLen)
			if err != nil {
				return err
			}

			if d.outPos < int(distance) {
				return errors.New("pkware: invalid back-reference distance")
			}

			// Copy bytes (handle overlapping)
			srcPos := d.outPos - int(distance)
			for i := uint32(0); i < copyLen; i++ {
				if d.outPos >= len(d.output) {
					return errors.New("pkware: output buffer overflow")
				}
				d.output[d.outPos] = d.output[srcPos]
				d.outPos++
				srcPos++
			}
		}
	}

	return nil
}
